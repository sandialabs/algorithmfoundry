/*
 * File:                ProbabilityMassFunctionUtil.java
 * Authors:             Kevin R. Dixon
 * Company:             Sandia National Laboratories
 * Project:             Cognitive Foundry
 * 
 * Copyright Feb 3, 2009, Sandia Corporation.
 * Under the terms of Contract DE-AC04-94AL85000, there is a non-exclusive
 * license for use of this work by or on behalf of the U.S. Government. 
 * Export of this program may require a license from the United States
 * Government. See CopyrightHistory.txt for complete details.
 * 
 */

package gov.sandia.cognition.statistics;

import gov.sandia.cognition.annotation.PublicationReference;
import gov.sandia.cognition.annotation.PublicationType;
import gov.sandia.cognition.collection.CollectionUtil;
import gov.sandia.cognition.learning.data.DefaultInputOutputPair;
import gov.sandia.cognition.learning.data.InputOutputPair;
import gov.sandia.cognition.math.ProbabilityUtil;
import gov.sandia.cognition.math.UnivariateStatisticsUtil;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Random;

/**
 * Utility methods for helping computations in PMFs.
 * @author Kevin R. Dixon
 * @since 3.0
 */
public class ProbabilityMassFunctionUtil
{

    /**
     * Computes the information-theoretic entropy of the PMF in bits.
     * @param <DataType>
     * Type of data on the domain of the PMF.
     * @param pmf
     * PMF to compute the entropy.
     * @return
     * Entropy in bits of the given PMF.
     */
    @PublicationReference(
        author="Wikipedia",
        title="Entropy (information theory)",
        type=PublicationType.WebPage,
        year=2009,
        url="http://en.wikipedia.org/wiki/Entropy_(Information_theory)"
    )
    public static <DataType> double getEntropy(
        ProbabilityMassFunction<DataType> pmf )
    {
        // Compute the entropy by looping over the values in the maps
        Collection<? extends DataType> domain = pmf.getDomain();
        ArrayList<Double> data = new ArrayList<Double>( domain.size() );
        for( DataType input : domain )
        {
            data.add( pmf.evaluate( input ) );
        }

        return UnivariateStatisticsUtil.computeEntropy(data);

    }

    /**
     * Samples from the ProbabilityMassFunction.  The return value will be
     * sampled according to the given PMF.
     * @param <DataType> Type of data to use
     * @param pmf PMF from which to sample
     * @param random Random to sample from
     * @param numSamples Number of samples to draw from the given PMF.
     * @return
     * Samples drawn according to the given PMF.
     */
    public static <DataType> ArrayList<DataType> sample(
        ProbabilityMassFunction<DataType> pmf,
        Random random,
        int numSamples )
    {
        ArrayList<DataType> samples;
        if( numSamples == 1 )
        {
            samples = new ArrayList<DataType>( 1 );
            samples.add( sampleSingle(pmf, random) );
        }
        else
        {
            samples = sampleMultiple(pmf, random, numSamples);
        }
        return samples;
    }

    /**
     * Draws a single sample from the given PMF
     * @param <DataType>
     * Type of observations generated by the PMF
     * @param pmf
     * PMF from which to draw.
     * @param random
     * Random number generator
     * @return
     * Single sample from the PMF
     */
    public static <DataType> DataType sampleSingle(
        ProbabilityMassFunction<DataType> pmf,
        Random random )
    {
        double p = random.nextDouble();
        for( DataType x : pmf.getDomain() )
        {
            p -= pmf.evaluate(x);
            if( p <= 0.0 )
            {
                return x;
            }
        }
        return null;
    }

    /**
     * Samples from the ProbabilityMassFunction.  The return value will be
     * sampled according to the given PMF.
     * @param <DataType> Type of data to use
     * @param pmf PMF from which to sample
     * @param random Random to sample from
     * @param numSamples Number of samples to draw from the given PMF.
     * @return
     * Samples drawn according to the given PMF.
     */
    @SuppressWarnings("unchecked")
    public static <DataType> ArrayList<DataType> sampleMultiple(
        ProbabilityMassFunction<DataType> pmf,
        Random random,
        int numSamples )
    {

        // Compute the cumulative probability counts.
        // We can then use binary search to make the lookup process VERY zoomy.
        int N = pmf.getDomain().size();
        double[] cumulativeProbabilities = new double[ N ];
        ArrayList<? extends DataType> domain =
            CollectionUtil.asArrayList( pmf.getDomain() );
        double psum = 0.0;
        final int domainSize = domain.size();
        for( int index = 0; index < domainSize; index++ )
        {
            final DataType x = domain.get(index);
            psum += pmf.evaluate( x );
            cumulativeProbabilities[index] = psum;
        }

        int index;
        ArrayList<DataType> samples = new ArrayList<DataType>( numSamples );
        for( int n = 0; n < numSamples; n++ )
        {
            double p = random.nextDouble();
            index = Arrays.binarySearch( cumulativeProbabilities, p );
            if( index < 0 )
            {
                int insertionPoint = -index - 1;
                index = insertionPoint;
            }
            samples.add( domain.get(index) );
        }
        
        return samples;
        
    }

    /**
     * Inverts the discrete CDF, that is p=Pr{x<=X}.
     * @param <DataType> Type of number from the distribution
     * @param cdf
     * CDF of a discrete distribution.
     * @param p
     * Probability to invert, must be [0,1].
     * @return
     * Value of x such that p >= CDF(x) and p <= CDF(x_next).
     */
    public static <DataType extends Number> InputOutputPair<DataType,Double> inverse(
        CumulativeDistributionFunction<DataType> cdf,
        double p )
    {
        ProbabilityUtil.assertIsProbability(p);
        for( DataType x : ((DiscreteDistribution<DataType>) cdf).getDomain() )
        {
            final double px = cdf.evaluate(x);
            if( p <= px )
            {
                return new DefaultInputOutputPair<DataType, Double>( x, px );
            }
        }
        throw new IllegalArgumentException(
            "Could not invert CDF for p=" + p );
    }

    /**
     * Computes the CDF value for the given PMF for the input.  That is,
     * the value of P=CDF(input)=sum(PMF(x<=input)).
     * @param input
     * Input to compute the CDF of.
     * @param distribution
     * Distribution to consider.
     * @return
     * CDF value of the distirbution for the given input
     */
    public static double computeCumulativeValue(
        int input,
        ClosedFormDiscreteScalarDistribution<? super Integer> distribution )
    {

        int minx = distribution.getMinSupport().intValue();
        ProbabilityMassFunction<? super Integer> pmf =
            distribution.getProbabilityFunction();
        double sum = 0.0;
        for( int x = minx; x <= input; x++ )
        {
            sum += pmf.evaluate(x);
        }

        return sum;
    }

}
